/**
Ross Wagner
4/15/2018

This program takes in tokens generated by lexical.c and determines if the
PL/0 program is well formed (syntatically correct)




*/


#include "codes.h"
#include "parser.h"

// global vars
symbol symbolTable[MAX_SYMBOL_TABLE_SIZE];
int symbolTableIndex = 0;

// global error node
token errorToke;
node errorNode;

// error flag
int errorFlag = 0;

// where errors are stored. global so I dont have to
FILE* errorFile;


int lexicalLevel = 0;

/*
// for testing
int main(int argc, char** argv){

  if(argc != 2){
    printf("Usage: ./parse <PM0 source file>\n" );
    return ERROR;
  }

  errorFile = fopen("errors.txt", "w");
  if(!errorFile){
    printf("Failed to open errors.txt");
  }
  // get lexem list
  char * code = fileNameToStr(argv[1]);

  if(code == NULL){
    printf("Failed to read file");
    return ERROR;
  }

  // init the error node
  strcpy(errorToke.text,"");
  errorToke.atribute = -1;
  errorNode.token = errorToke;
  errorNode.next = NULL;
  errorNode.prev = NULL;

  //printf("%s", code);

  node * lexTable = NULL;
  lexTable = makeLexTable(&code);

  parse(lexTable);

}
*/

/**
@params current node in a linked list of token nodes

@returns an int, a status code
*/
int block(node * current){
  // const declaration
  if (current->token.atribute == constsym){
    int atribute = current->token.atribute;
    do {
      // init new const sym
      symbol newSym;
      newSym.atribute=atribute;
      newSym.level = lexicalLevel;
      newSym.addr = current->token.line;

      *current = *getNextLex(current);
      if (current->token.atribute != identsym){
        error(27,current->token.line);
        return ERROR;
      }
      // set name
      strcpy(newSym.name, current->token.text);

      *current = *getNextLex(current);
      if (current->token.atribute != eqsym){
        error(3,current->token.line);
        return ERROR;
      }

      *current = *getNextLex(current);
      if(current->token.atribute != numbersym){
        error(2,current->token.line);
        return ERROR;
      }
      // set value
      newSym.value = (int) strtol(current->token.text, (char **)NULL, 10);

      // add to symbol table
      enter(newSym);

      *current = *getNextLex(current);

    } while(current->token.atribute == commasym);

    if(current->token.atribute != semicolonsym){
      error(5, current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
  }

  // var declaration
  if(current->token.atribute == intsym || current->token.atribute == varsym){
    int atribute = current->token.atribute;
    do {
      symbol newSym;
      newSym.atribute = atribute;
      newSym.level = lexicalLevel;
      newSym.addr = current->token.line;
      newSym.value = 0;

      *current = *getNextLex(current);
      if (current->token.atribute != identsym){
        error(27,current->token.line);
        return ERROR;
      }

      // coppy text to new symbol
      strcpy(newSym.name, current->token.text);


      *current = *getNextLex(current);

      // add to symbol table
      enter(newSym);

    } while(current->token.atribute == commasym);

    if(current->token.atribute != semicolonsym){
      error(5,current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
  }

  // procedure declaration
  while(current->token.atribute == procsym){
    *current = *getNextLex(current);
    if(current->token.atribute != identsym){
      error(27, current->token.line);
      return ERROR;
    }

    // create and add new symbol
    symbol newSym;
    newSym.atribute = procsym;
    strcpy(newSym.name, current->token.text);
    newSym.level = lexicalLevel;
    newSym.addr = current->token.line;
    newSym.value = 0;
    enter(newSym);

    *current = *getNextLex(current);
    if(current ->token.atribute = semicolonsym){
      error(5, current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
    lexicalLevel++;
    block(current);
    lexicalLevel--;
    //return ERROR;

    if(current ->token.atribute = semicolonsym){
      error(5, current->token.line);
      return ERROR;
    }
  }

  return statement(current);
  //return OK;
}

int condition(node * current){
  // odd
  if(current->token.atribute == oddsym){
    *current = *getNextLex(current);
    expression(current);
    if(errorFlag){
      return ERROR;
    }
  }
  else{
    expression(current);
    if(errorFlag){
      return ERROR;
    }

    if(!(current->token.atribute == eqsym || current->token.atribute ==neqsym ||
      current->token.atribute ==lessym || current->token.atribute == leqsym ||
      current->token.atribute == gtrsym || current->token.atribute == geqsym)){

      error(20, current->token.line);
      return ERROR;

    }

    *current = *getNextLex(current);
    expression(current);
    if(errorFlag){
      return ERROR;
    }
  }

  return OK;
}

/***/
int enter(symbol newSym){
  if(symbolTableIndex >= MAX_SYMBOL_TABLE_SIZE){
    error(29,newSym.addr);
    return ERROR;
  }
  else{
    symbolTable[symbolTableIndex++] = newSym;
    return OK;
  }
}

/**
code meaning for the error function
1. Use = instead of :=.
2. = must be followed by a number.
3. Identifier must be followed by =.
4. const, var, procedure must be followed by identifier.
5. Semicolon or comma missing.
6. Incorrect symbol after procedure declaration.
7. Statement expected.
8. Incorrect symbol after statement part in block.
9. Period expected.
10. Semicolon between statements missing.
11. Undeclared identifier.
12. Assignment to constant or procedure is not allowed.
13. Assignment operator expected.
14. call must be followed by an identifier.
15. Call of a constant or variable is meaningless.
16. then expected.
17. Semicolon or } expected.
18. do expected.
19. Incorrect symbol following statement.
20. Relational operator expected.
21. Expression must not contain a procedure identifier.
22. Right parenthesis missing.
23. The preceding factor cannot begin with this symbol.
24. An expression cannot begin with this symbol.
25. This number is too large.
26. Unexpected end of file/lexem table
27. Identifier expected
28. := expected.
29. Max symbol table size exeded
30. begin must be closed with end
*/
void error(int eCode, int line){

  fprintf(errorFile,"Error line %d: ", line);

  switch(eCode){
    case 1:
      fprintf(errorFile,"Use = instead of :=.\n");
      break;
    case 2:
      fprintf(errorFile,"= must be followed by a number.\n");
      break;
    case 3:
      fprintf(errorFile,"Identifier must be followed by =.\n");
      break;
    case 4:
      fprintf(errorFile,"const, var, procedure must be followed by identifier.\n");
      break;
    case 5:
      fprintf(errorFile,"Semicolon or comma missing.\n");
      break;
    case 6:
      fprintf(errorFile, "Incorrect symbol after procedure declaration.\n");
      break;
    case 7:
      fprintf(errorFile, "Statement expected.\n");
      break;
    case 8:
      fprintf(errorFile, "Incorrect symbol after statement part in block.\n");
      break;
    case 9:
      fprintf(errorFile,"Period expected.\n");
      break;
    case 10:
      fprintf(errorFile,"Semicolon between statements missing.\n");
      break;
    case 11:
      fprintf(errorFile,"Undeclared identifier.\n");
      break;
    case 12:
      fprintf(errorFile,"Assignment to constant or procedure is not allowed\n");
      break;
    case 13:
      fprintf(errorFile,"Assignment operator expected.\n");
      break;
    case 14:
      fprintf(errorFile,"call must be followed by an identifier.\n");
      break;
    case 15:
      fprintf(errorFile,"Call of a constant or variable is meaningless.\n");
      break;
    case 16:
      fprintf(errorFile,"then expected.\n");
      break;
    case 17:
      fprintf(errorFile,"Semicolon or } expected.\n");
      break;
    case 18:
      fprintf(errorFile,"do expected.\n");
      break;
    case 19:
      fprintf(errorFile,"Incorrect symbol following statement.\n");
      break;
    case 20:
      fprintf(errorFile,"Relational operator expected.\n");
      break;
    case 21:
      fprintf(errorFile,"Expression must not contain a procedure identifier.\n");
      break;
    case 22:
      fprintf(errorFile,"Right parenthesis missing.\n");
      break;
    case 23:
      fprintf(errorFile,"The preceding factor cannot begin with this symbol.\n");
      break;
    case 24:
      fprintf(errorFile,"An expression cannot begin with this symbol.\n");
      break;
    case 25:
      fprintf(errorFile,"This number is too large.\n");
      break;
    case 26:
      fprintf(errorFile, "Unexpected end of file/program/lexem table.\n" );
      break;
    case 27:
      fprintf(errorFile,"Identifier expected.\n");
      break;
    case 28:
      fprintf(errorFile,":= expected.\n");
      break;
    case 29:
      fprintf(errorFile, "Max symbol table size exeded.\n");
      break;
    case 30:
      fprintf(errorFile, "begin must be closed with end.\n" );
      break;
    case 31:
      fprintf(errorFile, "if condition must be followed by then.\n" );
      break;
    case 32:
      fprintf(errorFile, "while condition must be followed by do.\n" );
      break;
    case 33:
      fprintf(errorFile, "identifier, (, or number expected.\n" );
      break;

  }
  errorFlag = 1;
}

/*
+/- chains
*/
int expression(node * current){
  if (current->token.atribute == plussym || current->token.atribute == minussym){
    *current = *getNextLex(current);
  }
  term(current);
  if(errorFlag){
    return ERROR;
  }

  while(current->token.atribute == plussym || current->token.atribute == minussym){
    *current = *getNextLex(current);
    term(current);
    if(errorFlag){
      return ERROR;
    }
  }

  return OK;
}

int factor(node * current){
  if(current->token.atribute == identsym){
    *current = *getNextLex(current);
  }
  else if(current->token.atribute == numbersym){
    *current = *getNextLex(current);
  }
  else if(current->token.atribute == lparentsym){
    *current = *getNextLex(current);

    expression(current);
    if(errorFlag){
      return ERROR;
    }

    if(current->token.atribute != rparentsym){
      error(22,current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);

  }

  else{
    error(34,current->token.line);
    return ERROR;
  }

  return OK;
}

node * getNextLex(node * current){
  node * next = current->next;

  // check if tail sentinal node
  if(next == NULL || next->next == NULL){
    //error unexpected end
    error(26, current->token.line);

    // create dummy error node
    return &errorNode;
  }
  else{
    // debug
    printf("nextTok: %s atribute: %d\n", next->token.text, next->token.atribute);

    return next;
  }
}

int parse(node * lexTable){
  node * current = getNextLex(lexTable);
  *current = *getNextLex(lexTable);

  block(current);

  if (errorFlag){
    return ERROR;
  }

  if (current->token.atribute != periodsym){
    error(9, current->token.line);
    return ERROR;
  }

  return OK;

}

void printSymbolTable(){
  int i;
  for(i = 0; i < symbolTableIndex; i++){
    symbol sym = symbolTable[i];
    printf("atribute: %d name: %s value: %d levle: %d addr: %d\n",
      sym.atribute,sym.name,sym.value,sym.level,sym.addr);
  }
}

/**

calls condition, expression, and its self. is called by block.

deals with Assignments, call, begin, if, and while



*/
int statement(node * current){
  int status = OK;
  // Assignment statement
  if(current->token.atribute == identsym){
    *current = *getNextLex(current);
    if(current->token.atribute != becomessym){
      error(28, current->token.line);
      return ERROR;
    }
    *current = *getNextLex(current);
    status = expression(current);
    if(status != OK){
      return status;
    }
  }

  // read
  else if (current->token.atribute == readsym){
    *current = *getNextLex(current);
    // expect an identifier
    if(current->token.atribute != identsym){
      error(27, current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
    // expect  ;
    if(current->token.atribute != semicolonsym){
      error(5, current->token.line);
      return ERROR;
    }
    // generate code to read input here

  }

  // write
  else if (current->token.atribute == writesym){
    *current = *getNextLex(current);
    // expect an identifier
    if(current->token.atribute != identsym){
      error(27, current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
    // expect  ;
    if(current->token.atribute != semicolonsym){
      error(5, current->token.line);
      return ERROR;
    }
    // generate code to write output here

  }

  // procedure call
  else if(current->token.atribute == callsym){
    *current = *getNextLex(current);
    if(current->token.atribute != identsym){
      error(27, current->token.line);
      return ERROR;
    }
    *current = *getNextLex(current);
  }

  // begin
  else if(current->token.atribute == beginsym){
    *current = *getNextLex(current);
    status = statement(current);
    if(errorFlag){
      return ERROR;
    }
    while(current->token.atribute == semicolonsym){
      *current = *getNextLex(current);
      statement(current);
      if(errorFlag){
        return ERROR;
      }
    }
    if (current->token.atribute != endsym){
      error(30,current->token.line);
      return ERROR;
    }
    *current = *getNextLex(current);
  }

  // if statement
  else if(current->token.atribute == ifsym){
    *current = *getNextLex(current);
    condition(current);
    if(errorFlag){
      return ERROR;
    }

    if (current->token.atribute != thensym){
      error(31,current->token.line);
      return ERROR;
    }
    *current = *getNextLex(current);

    statement(current);
    if(errorFlag){
      return ERROR;
    }
  }

  // while statement
  else if(current->token.atribute == whilesym){
    *current = *getNextLex(current);

    condition(current);
    if(errorFlag){
      return ERROR;
    }

    if(current->token.atribute != dosym){
      error(33, current->token.line);
      return ERROR;
    }

    *current = *getNextLex(current);
    statement(current);
    if(errorFlag){
      return ERROR;
    }

  }


  return status;
}

/**
multiplication and division
*/
int term(node * current){
  factor(current);
  if(errorFlag){
    return ERROR;
  }

  while(current->token.atribute == multsym || current->token.atribute == slashsym){
    *current = *getNextLex(current);
    factor(current);
    if(errorFlag){
      return ERROR;
    }
  }

  return OK;
}
