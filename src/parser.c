/**
Ross Wagner
4/15/2018

This program takes in tokens generated by lexical.c and determines if the
PL/0 program is well formed (syntatically correct)




*/


#include "codes.h"
#include "parser.h"

// global vars
symbol symbolTable[MAX_SYMBOL_TABLE_SIZE];
int symbolTableIndex = 0;

// global error node
token errorToke;
node errorNode;

// error flag
int errorFlag = 0;


// where errors are stored. global so I dont have to
FILE* errorFile;



/*
// for testing
int main(int argc, char** argv){

  if(argc != 2){
    printf("Usage: ./parse <PM0 source file>\n" );
    return ERROR;
  }

  errorFile = fopen("errors.txt", "w");
  if(!errorFile){
    printf("Failed to open errors.txt");
  }
  // get lexem list
  char * code = fileNameToStr(argv[1]);

  if(code == NULL){
    printf("Failed to read file");
    return ERROR;
  }

  // init the error node
  strcpy(errorToke.text,"");
  errorToke.atribute = -1;
  errorNode.token = errorToke;
  errorNode.next = NULL;
  errorNode.prev = NULL;

  //printf("%s", code);

  node * lexTable = NULL;
  lexTable = makeLexTable(&code);

  parse(lexTable);

}
*/

/**
@params current node in a linked list of token nodes

@returns an int, a status code
*/
int block(node * current){
  // const declaration
  if (current->token.atribute == constsym){
    do {
      // init new const sym
      symbol newSym;
      newSym.atribute=current->token.atribute;
      newSym.level = 0;
      newSym.addr = 0;

      current = getNextLex(current);
      if (current->token.atribute != identsym){
        error(27);
        return ERROR;
      }
      // set name
      strcpy(newSym.name, current->token.text);

      current = getNextLex(current);
      if (current->token.atribute != eqsym){
        error(3);
        return ERROR;
      }

      current = getNextLex(current);
      if(current->token.atribute != numbersym){
        error(2);
        return ERROR;
      }
      // set value
      newSym.val = (int) strtol(current->token.text, (char **)NULL, 10);

      // add to symbol table
      enter(newSym);



      current = getNextLex(current);

    } while(current->token.atribute == commasym);

    if(current->token.atribute != semicolonsym){
      error(5);
      return ERROR;
    }

    current = getNextLex(current);
  }

  // var declaration
  if(current->token.atribute == intsym){
    do {

      current = getNextLex(current);
      if (current->token.atribute != identsym){
        error(27);
        return ERROR;
      }

      current = getNextLex(current);

    } while(current->token.atribute == commasym);

    if(current->token.atribute != semicolonsym){
      error(5);
      return ERROR;
    }

    current = getNextLex(current);
  }

  // procedure declaration
  while(current->token.atribute = procsym){
    current = getNextLex(current);
    if(current->token.atribute != identsym){
      error(27);
      return ERROR;
    }

    current = getNextLex(current);
    if(current ->token.atribute = semicolonsym){
      error(5);
      return ERROR;
    }

    current = getNextLex(current);
    block(current);
    return ERROR;

    if(current ->token.atribute = semicolonsym){
      error(5);
      return ERROR;
    }
  }

  return statement(current);
  //return OK;
}

/***/
int enter(symbol newSym){
  if(symbolTableIndex >= MAX_SYMBOL_TABLE_SIZE){
    error(29);
    return ERROR;
  }
  else{
    symbolTable[symbolTableIndex++] = newSym;
    return OK;
  }
}

/**
code meaning for the error function
1. Use = instead of :=.
2. = must be followed by a number.
3. Identifier must be followed by =.
4. const, var, procedure must be followed by identifier.
5. Semicolon or comma missing.
6. Incorrect symbol after procedure declaration.
7. Statement expected.
8. Incorrect symbol after statement part in block.
9. Period expected.
10. Semicolon between statements missing.
11. Undeclared identifier.
12. Assignment to constant or procedure is not allowed.
13. Assignment operator expected.
14. call must be followed by an identifier.
15. Call of a constant or variable is meaningless.
16. then expected.
17. Semicolon or } expected.
18. do expected.
19. Incorrect symbol following statement.
20. Relational operator expected.
21. Expression must not contain a procedure identifier.
22. Right parenthesis missing.
23. The preceding factor cannot begin with this symbol.
24. An expression cannot begin with this symbol.
25. This number is too large.
26. Unexpected end of file/lexem table
27. Identifier expected
28. := expected.
29. Max symbol table size exeded
*/
void error(int eCode){
  switch(eCode){
    case 1:
      fprintf(errorFile,"Use = instead of :=.\n");
      break;
    case 2:
      fprintf(errorFile,"= must be followed by a number.\n");
      break;
    case 3:
      fprintf(errorFile,"Identifier must be followed by =.\n");
      break;
    case 4:
      fprintf(errorFile,"const, var, procedure must be followed by identifier.\n");
      break;
    case 5:
      fprintf(errorFile,"Semicolon or comma missing.\n");
      break;
    case 6:
      fprintf(errorFile, "Incorrect symbol after procedure declaration.\n");
      break;
    case 7:
      fprintf(errorFile, "Statement expected.\n");
      break;
    case 8:
      fprintf(errorFile, "Incorrect symbol after statement part in block.\n");
      break;
    case 9:
      fprintf(errorFile,"Period expected.\n");
      break;
    case 10:
      fprintf(errorFile,"Semicolon between statements missing.\n");
      break;
    case 11:
      fprintf(errorFile,"Undeclared identifier.\n");
      break;
    case 12:
      fprintf(errorFile,"Assignment to constant or procedure is not allowed\n");
      break;
    case 13:
      fprintf(errorFile,"Assignment operator expected.\n");
      break;
    case 14:
      fprintf(errorFile,"call must be followed by an identifier.\n");
      break;
    case 15:
      fprintf(errorFile,"Call of a constant or variable is meaningless.\n");
      break;
    case 16:
      fprintf(errorFile,"then expected.\n");
      break;
    case 17:
      fprintf(errorFile,"Semicolon or } expected.\n");
      break;
    case 18:
      fprintf(errorFile,"do expected.\n");
      break;
    case 19:
      fprintf(errorFile,"Incorrect symbol following statement.\n");
      break;
    case 20:
      fprintf(errorFile,"Relational operator expected.\n");
      break;
    case 21:
      fprintf(errorFile,"Expression must not contain a procedure identifier.\n");
      break;
    case 22:
      fprintf(errorFile,"Right parenthesis missing.\n");
      break;
    case 23:
      fprintf(errorFile,"The preceding factor cannot begin with this symbol.\n");
      break;
    case 24:
      fprintf(errorFile,"An expression cannot begin with this symbol.\n");
      break;
    case 25:
      fprintf(errorFile,"This number is too large.\n");
      break;
    case 26:
      fprintf(errorFile, "Unexpected end of file/program/lexem table.\n" );
      break;
    case 27:
      fprintf(errorFile,"Identifier expected.\n");
      break;
    case 28:
      fprintf(errorFile,":= expected.\n");
      break;
  }
  errorFlag = 1;
}

int expression(node * current){
  if (current->token.atribute == plussym || current->token.atribute == minussym){
    current = getNextLex(current);
  }
  //while()
  // to do

  return OK;
}

node * getNextLex(node * current){
  node * next = current->next;

  // check if tail sentinal node
  if(next == NULL || next->next == NULL){
    //error unexpected end
    error(26);

    // create dummy error node
    return &errorNode;
  }
  else{
    return next;
  }
}

int parse(node * lexTable){
  node * current = getNextLex(lexTable);

  block(current);

  if (errorFlag){
    return ERROR;
  }

  if (current->token.atribute != periodsym){
    error(9);
    return ERROR;
  }

  return OK;

}

int statement(node * current){
  int status = OK;
  if(current->token.atribute == identsym){
    current = getNextLex(current);
    if(current->token.atribute != becomessym){
      error(28);
      return ERROR;
    }
    current = getNextLex(current);
    status = expression(current);
    if(status != OK){
      return status;
    }
  }

  return status;
}
